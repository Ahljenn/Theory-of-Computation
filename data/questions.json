[
    {
      "question": "What are the possible outputs of a terminating nondeterministic computation?",
      "answer": "If all leaves of a (finite) computation tree, T, are negative, the output is 'no'. If T has any positive leaves, any one of the positive return values is a possible output; Otherwise, output is undefined. - 151"
    },
    {
      "question": "When does an nondeterministic finite automaton (NFA) accept a string?",
      "answer": "Accepts if any clone accepts. Rejects if all clones reject. Otherwise, output is undefined (Clone can enter an infinite loop). - 170"
    },
    {
      "question": "When does a decision problem have a polynomial-time mapping reduction?",
      "answer": "A decision problem F has a polynomial-time mapping reduction to problem G ( F =<_P G) if there exists a polytime program C (for Convert) that converts instances of F into instances of G, such that C maps positive instances of F to positive instances of G, and negative instances of F to negatives instances of G. - 273"
    },
    {
      "question": "What is a Tseytin transformation?",
      "answer": "Converts any Boolean circuit into a 3-CNF (conjunctive normal form) formula in linear time. Utilized in particular polyreductions."
    },
    {
      "question": "Is a Turing machine as powerful as finite automata? Why or why not?",
      "answer": "Turing machines are strictly more powerful than finite automata since they can use their tape to remember as much information as desired - finite set of states but infinitely many possible configurations. - 183"
    },
    {
      "question": "When does a program P recognize a language L?",
      "answer": "For all I ∈ L, P(I) = 'yes'. For all I ∉ L, either P(I) is undefined or P(I) = 'no.' It must decide on all positive instances. - 65"
    },
    {
      "question": "When does a program P decide a language L?",
      "answer": "A language or decision problem is decidable if some program correctly decides all instances, whether positive or negative. - 113"
    },
    {
      "question": "How can it be that universal computation appears in the real world?",
      "answer": "There exists universal Python programs that can simulate other python programs. It has also been observed there exists an equivalent Turing machine U. Any modern computer has universally built into it at several layers through some form of abstraction. - 107"
    },
    {
      "question": "What is considered a 'computational step?'",
      "answer": "A single CPU instruction for a Python program, or single transition for a Turing machine - 129"
    },
    {
      "question": "Why would a verifier output 'unsure?' and never 'incorrect?'",
      "answer": "The proposed solution is actually incorrect or the hint was wrong. There is no way in distinguishing these two cases so verifiers only output 'correct' or 'unsure.' - 253"
    },
    {
      "question": "What does a deterministic finite automaton (DFA) consist of?",
      "answer": "An alphabet Σ of symbols, including blank symbol; State set Q, including start state q-0, and atleast one of the halting states (q-accept, q-reject). - 164"
    },
    {
      "question": "When is a computational problem NP-hard?",
      "answer": "A computational problem F is NP-hard if there exists some NP-complete problems C with C <=_P F. - 299"
    },
    {
      "question": "What are the five computational problems?",
      "answer": "Search, Decision, Threshold, Optimization, Function - 57"
    },
    {
      "question": "What is circuit satisfiability?",
      "answer": "Given an electrical circuit with a large number of inputs and one output, is it possible for the output of the circuit to be 1? Any setting that produces a 1 is said to satisfy the circuit. - 281"
    },
    {
      "question": "How does adding nondeterminsim effect a computational model in terms of computability and complexity?",
      "answer": "Does not change what we can compute, but changes how fast we can compute it. - 170"
    },
    {
      "question": "What is the essence of P vs. NP?",
      "answer": "Are P and NP the same complexity class? That is, do they each consist of the same set of decision problems? - 294"
    },
    {
      "question": "What does a nondeterministic turing machine consist of?",
      "answer": "The transition function that maps (q, x) to a finite set of possible 3-tuples (rather than a single 3-tuple). (q' - new state, x' - new symbol, d' - direction to move). - 74"
    },
    {
      "question": "What is a regular language?",
      "answer": "A language is regular iff it is decided by some DFA or NFA, or alternatively represented by some regular expression. - 181"
    },
    {
      "question": "What is a consequence if P = NP?",
      "answer": "If P = NP then it must be possible to convert any polytime, nondeterministic program ND.py into a polytime, deterministic program D.py that computes the same answers. Recall: Programs are equivalent if they produce the same answers on the same inputs. - 295"
    },
    {
      "question": "What are the three factors of runtime?",
      "answer": "Dependence on hardware. Dependence on easy or hard input. Dependence on length of the input. - 196"
    },
    {
      "question": "What is the halting problem and why is it practical?",
      "answer": "Given any program P and input I, we ask does P terminate (or halt) on input I? Some types of software halt such as computational programs whereas some run indefinitely (i.e: Operating Systems and Web servers.) - 126"
    },
    {
      "question": "What does it mean if two computational models are said to be 'Turing equivalent?'",
      "answer": "Two computational models are 'Turing equivalent' if they can solve the same set of problems. - 98"
    },
    {
      "question": "Name the key differences between Turing machines and finite automata.",
      "answer": "DFA - fixed, finite number of states (limited). Turing machine - finite set of states but seemingly infinite memory - 183"
    },
    {
      "question": "What are the key points on the boundary of the complexity classes Poly and Expo?",
      "answer": "Problems that seem similar can have very different complexities. Some Expo problems are easily proved to be outside of Poly. Many problems seem to require superpolynomial time, but haven’t been proved to require superpolynomial time. - 231"
    },
    {
      "question": "What are some properties of Turing reductions?",
      "answer": "Turing-reducibility is transitive. Propagation of computability - If F reduces to G then: (a) if G is computable, then F is computable. (b) if F is uncomputable, then G is uncomputable. - 122"
    },
    {
      "question": "What is the difference between a strict NFA and an NFA?",
      "answer": "A strict NFA transition fucntion maps to set of states. An NFA allows for ∈-transitions. - 169"
    },
    {
      "question": "What is implied if F 'polyreduces' to G?",
      "answer": "If you can solve G in polynomial time, you can also solve F in polynomial time. - 273"
    },
    {
      "question": "What is a verifier?",
      "answer": "A program that checks solutions to computation problems. - 250"
    },
    {
      "question": "Why are PolyCheck and NPoly identical?",
      "answer": "PolyCheck is in NPoly, and vice versa. - 259"
    },
    {
      "question": "When is a property asymptotic?",
      "answer": "A property is asymptotic if it only depends on sufficiently large values of n. - 202"
    },
    {
      "question": "What are common big-O mistakes?",
      "answer": "Forgetting 'at most'. Constants or extra terms inside O(.) are misleading even though it's technically not wrong. - 202"
    },
    {
      "question": "What does it mean for a program to be recognizable?",
      "answer": "There's a program that: always terminates with the right answer ('yes') on positive instances, never wrong on negative instances, may enter an infinite loop on negative instances. - 113"
    },
    {
      "question": "Which complexity class(es) does not depend on the type of computational model used?",
      "answer": "Poly and Expo - 238"
    },
    {
      "question": "What is a computational problem?",
      "answer": "Given an alphabet Σ, a computational problem is a function mapping strings on Σ to sets of strings on Σ. - 62"
    },
    {
      "question": "What is implied if F 'reduces' to G?",
      "answer": "F can be solved if G can be solved; F is no harder than G. - 116"
    },
    {
      "question": "What are the five operations on languages?",
      "answer": "Union, intersection, complement, concatenation, repetition (Kleene star). - 52"
    },
    {
      "question": "What is the significance of a regular expression (regex) in terms of the theory of computation?",
      "answer": "Given any DFA or NFA, there is an equivalent regular expression. Given any regular expression, there is an equivalent DFA. - 180"
    },
    {
      "question": "What are the three main models of nondeterminism?",
      "answer": "Simultaneous threads. Random choice. External choice. - 158"
    },
    {
      "question": "What is a computation tree?",
      "answer": "A type of labeled graph that helps visualize the effect of a nondeterministic program. - 149"
    },
    {
      "question": "When is a computational problem F in the complexity class PolyCheck?",
      "answer": "F is in PolyCheck if we can verify / check its positive instances in polynomial time. - 256"
    },
    {
      "question": "When do we call a program 'deterministic?'",
      "answer": "A program is said to be 'deterministic' if its execution path is uniquely determined by the state of C when the program begins executing.' - 24"
    },
    {
      "question": "Why is P a subset of NP?",
      "answer": "Any decision problem D in NP can be solved by some determinstic polytime program. But a determinstic program is just a special case of a non-determionstic one that uses only one thread. Thus D can be regarded as a non-determinstic polytime program that solves D, thus D is in NP. - 295"
    },
    {
      "question": "What is diagonalization?",
      "answer": "The idea that a program can analyze itself when given itself as input. - 39"
    },
    {
      "question": "What is an accepter?",
      "answer": "A Turing machine where we are only interested in the accept/reject decision. - 77"
    },
    {
      "question": "What is transducer?",
      "answer": "A Turing machine where we are only itnerested in the output. - 77"
    },
    {
      "question": "Why is Poly a subset of Expo?",
      "answer": "Given any polynomial n^k, the function 2^n dominates n^k. Thus, any algorithm that is in O(n^k) is also in O(2^n). - 230"
    },
    {
      "question": "What are the main uses of Turing reductions?",
      "answer": "The main use of Turing reductions is to spread 'proven impossibility' to new problems; Show that a problem is hard (uncomputable), - 116"
    },
    {
      "question": "Main difference between NP-hard vs. NP-complete?",
      "answer": "A computational problem F is NP-hard if there exists some NP-complete problem C with C polyreducing to F. NP-complete problems must be in NP (PolyCheck/NPoly), decision problems only. NP-hard problems may be outside and do not have to be decision problems (like HaltEx). NP-Complete ⊆ NPHard, but not the converse. - 298"
    },
    {
      "question": "What is the consequence of polyequivalence?",
      "answer": "If problems are polyequivalent, either all problems can be solved in polynomial time, or none of them can be solved. (i.e: CircuitSAT ≡ SAT ≡ 3-SAT). - 290"
    },
    {
      "question": "To what extent can NP-hard problems be solved or approximted?",
      "answer": "NP-hard problems can be approximated efficiently. - 310"
    }
]